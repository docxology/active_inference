"""
Application Framework - Templates and Code Generation

Template library and code generation system for Active Inference applications.
Provides ready-to-use implementation patterns, boilerplate code, and automated
generation of common application structures.
"""

import logging
from typing import Dict, List, Optional, Any
from pathlib import Path
from dataclasses import dataclass
from enum import Enum
import json

logger = logging.getLogger(__name__)


class TemplateType(Enum):
    """Types of application templates"""
    BASIC_MODEL = "basic_model"
    RESEARCH_PIPELINE = "research_pipeline"
    SIMULATION_STUDY = "simulation_study"
    WEB_APPLICATION = "web_application"
    API_SERVICE = "api_service"
    EDUCATIONAL_TOOL = "educational_tool"


@dataclass
class TemplateConfig:
    """Configuration for template generation"""
    name: str
    template_type: TemplateType
    description: str
    parameters: Dict[str, Any] = None
    output_directory: Optional[Path] = None

    def __post_init__(self):
        if self.parameters is None:
            self.parameters = {}


class CodeGenerator:
    """Code generation engine for Active Inference applications"""

    def __init__(self, templates_dir: Path):
        self.templates_dir = Path(templates_dir)
        self.templates_dir.mkdir(parents=True, exist_ok=True)
        self.templates: Dict[str, Dict[str, Any]] = {}

        logger.info(f"CodeGenerator initialized with templates directory: {self.templates_dir}")

    def generate_basic_model(self, config: TemplateConfig) -> Dict[str, Any]:
        """Generate a basic Active Inference model"""
        model_code = f'''
"""
{config.name} - Active Inference Model

Generated by Active Inference Application Framework
"""

import numpy as np
from typing import Dict, List, Optional, Any
import logging

logger = logging.getLogger(__name__)


class {config.name.replace(' ', '').replace('-', '_')}:
    """
    Basic Active Inference model implementation.

    This model demonstrates core Active Inference principles including:
    - Generative model specification
    - Variational inference
    - Free energy minimization
    - Perception-action cycle
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.n_states = config.get("n_states", 4)
        self.n_observations = config.get("n_observations", 8)
        self.time_horizon = config.get("time_horizon", 1000)

        # Initialize generative model parameters
        self.initialize_model()

        logger.info(f"Initialized {config.name} with {self.n_states} states and {self.n_observations} observations")

    def initialize_model(self) -> None:
        """Initialize the generative model parameters"""
        # Transition matrix (A)
        self.A = np.random.dirichlet(np.ones(self.n_observations), self.n_states)

        # Transition beliefs (B)
        self.B = np.random.dirichlet(np.ones(self.n_states), self.n_states)

        # Prior preferences (C)
        self.C = np.random.uniform(0, 1, self.n_observations)

        # Initial state prior (D)
        self.D = np.random.dirichlet(np.ones(self.n_states))

    def perceive(self, observation: np.ndarray) -> Dict[str, Any]:
        """
        Process sensory input and update beliefs

        Args:
            observation: Sensory observation vector

        Returns:
            Dictionary containing updated beliefs and prediction error
        """
        # Compute prediction error
        prediction = self.A.dot(self.D)
        prediction_error = observation - prediction

        # Update posterior beliefs using variational inference
        # (Simplified implementation)
        posterior = self.D + 0.1 * prediction_error

        # Normalize
        posterior = posterior / np.sum(posterior)

        # Update state beliefs
        self.D = posterior

        return {{
            "posterior": posterior,
            "prediction_error": prediction_error,
            "prediction": prediction
        }}

    def act(self) -> int:
        """
        Select action based on expected free energy minimization

        Returns:
            Selected action
        """
        # Compute expected free energy for each action
        expected_fe = []

        for action in range(self.n_states):
            # Simplified expected free energy calculation
            fe = -np.dot(self.C, self.A[action])
            expected_fe.append(fe)

        # Select action with minimum expected free energy
        selected_action = np.argmin(expected_fe)

        logger.debug(f"Selected action {{selected_action}} with expected FE {{expected_fe[selected_action]}}")

        return selected_action

    def run_simulation(self, n_steps: int = 100) -> Dict[str, Any]:
        """
        Run a complete simulation

        Args:
            n_steps: Number of simulation steps

        Returns:
            Simulation results
        """
        results = {{
            "free_energy_history": [],
            "accuracy_history": [],
            "actions": [],
            "beliefs_history": []
        }}

        for step in range(n_steps):
            # Generate observation (simplified)
            true_state = np.random.choice(self.n_states)
            observation = np.random.multinomial(1, self.A[true_state])

            # Perception step
            perception_result = self.perceive(observation)

            # Action step
            action = self.act()

            # Compute free energy
            free_energy = -np.log(np.dot(observation, self.A.dot(self.D)))

            # Store results
            results["free_energy_history"].append(float(free_energy))
            results["actions"].append(int(action))
            results["beliefs_history"].append(perception_result["posterior"].tolist())

            # Compute accuracy
            accuracy = 1.0 if action == true_state else 0.0
            results["accuracy_history"].append(accuracy)

        logger.info(f"Simulation completed: {{n_steps}} steps")
        return results


# Example usage
if __name__ == "__main__":
    config = {{
        "n_states": 4,
        "n_observations": 8,
        "time_horizon": 1000
    }}

    model = {config.name.replace(' ', '').replace('-', '_')}(config)
    results = model.run_simulation(100)

    print(f"Final free energy: {{results['free_energy_history'][-1]".3f"}}")
    print(f"Average accuracy: {{np.mean(results['accuracy_history'])".3f"}}")
'''

        return {
            "files": {
                f"{config.name.lower().replace(' ', '_')}.py": model_code
            },
            "requirements": ["numpy", "typing"],
            "readme": f"# {config.name}\n\n{config.description}\n\nGenerated Active Inference model implementation."
        }

    def generate_research_pipeline(self, config: TemplateConfig) -> Dict[str, Any]:
        """Generate a complete research pipeline template"""
        # Similar implementation for research pipeline
        return {
            "files": {},
            "requirements": [],
            "readme": "Research pipeline template"
        }


class TemplateManager:
    """Manages application templates and generation"""

    def __init__(self, templates_dir: Path):
        self.templates_dir = Path(templates_dir)
        self.code_generator = CodeGenerator(self.templates_dir / "generated")
        self.templates: Dict[str, TemplateType] = {}

        logger.info("TemplateManager initialized")

    def generate_application(self, config: TemplateConfig) -> Dict[str, Any]:
        """Generate a complete application from template"""
        logger.info(f"Generating application: {config.name} ({config.template_type.value})")

        if config.template_type == TemplateType.BASIC_MODEL:
            return self.code_generator.generate_basic_model(config)
        elif config.template_type == TemplateType.RESEARCH_PIPELINE:
            return self.code_generator.generate_research_pipeline(config)
        else:
            logger.warning(f"Template type not implemented: {config.template_type}")
            return {}

    def list_available_templates(self) -> List[Dict[str, Any]]:
        """List all available templates"""
        return [
            {
                "name": template_type.value,
                "type": template_type.name,
                "description": f"Template for {template_type.value.replace('_', ' ')}"
            }
            for template_type in TemplateType
        ]

    def create_custom_template(self, template_data: Dict[str, Any]) -> bool:
        """Create a custom template"""
        template_name = template_data.get("name")
        if not template_name:
            logger.error("Template name required")
            return False

        template_file = self.templates_dir / "custom" / f"{template_name}.json"
        template_file.parent.mkdir(parents=True, exist_ok=True)

        with open(template_file, 'w') as f:
            json.dump(template_data, f, indent=2)

        logger.info(f"Created custom template: {template_name}")
        return True


class ApplicationFramework:
    """Main application framework coordinating templates and case studies"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.template_manager = TemplateManager(
            config.get("templates_dir", Path("./templates"))
        )

        logger.info("ApplicationFramework initialized")

    def create_application(self, template_type: TemplateType, name: str,
                          parameters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Create a new application from template"""
        config = TemplateConfig(
            name=name,
            template_type=template_type,
            description=f"Application generated from {template_type.value} template",
            parameters=parameters or {}
        )

        return self.template_manager.generate_application(config)

    def get_template_info(self, template_type: TemplateType) -> Dict[str, Any]:
        """Get information about a specific template"""
        templates = self.template_manager.list_available_templates()
        return next((t for t in templates if t["name"] == template_type.value), {})
